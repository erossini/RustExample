fn main() {
    // Constants can be declared in any scope and used globally
    // They differ from immutable variables in that their value
    // can't be defined at runtime (based on a function call for example)

    const ONE_MIL: u32 = 1_000_000;

    // as PI is never used it will raise a warning
    // Remember that you can avoid this with #![allow(unused)]
    // But an alternative is to preface the name with an "underscore" to
    // tell the compiler you know this is never used.

    const PI: f32 = 3.141592; 
    // const _PI: f32 = 3.141592; 

    // You can define variables with the same name but with different
    // data types (Shadowing)

    let age = "47";

    // Trim eliminates white space and parse converts the string into an int
    // We expect age to have an integer value and expect will throw an
    // error if this isn't true (We'll get more into error handling later)

    let mut age: u32 = age.trim().parse().expect("Age wasn't assigned a number");
    age = age + 1;

    println!("I'm {} and I want ${}", age, ONE_MIL);

    // ----- DATA TYPES -----
    // Rust is statically typed which means all types must be defined
    // These types are autogenerated by the compiler or defined explicitly

    // Unsigned integer : u8, u16, u32, u64, u128, usize
    // Signed integer : i8, i16, i32, i64, i128, isize

    let max_u32 = u32::MAX;
    println!("Max u32 : {}", max_u32);
    println!("Max u64 : {}", u64::MAX);

    // usize depends on your computer (If 64 bit then it's 64 bit)

    println!("Max usize : {}", usize::MAX);
    println!("Max u128 : {}", u128::MAX);

    // Floating Points : f32, f64

    println!("Max f32 : {}", f32::MAX);
    println!("Max f64 : {}", f64::MAX);

    // Booleans can have either the value true or false

    let _is_true = true;
    println!("Boolean : {}", _is_true);

    // Characters are defined with single quotes
    // They can store most any type of character from any language

    let _my_grade = 'A';
    println!("Character: {}", _my_grade);
}
